class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        //题目：找出数组中重复的数字 要求时间复杂度小与O(N^2) 空间复杂度O(1)//对于这种数组在[0,n-1]范围内的问题，可以将值为i的元素调整到第i个位置上
        //解法一：先排序再遍历(排序后相同数字都挨着)   时间O(NlogN) 空间：O(1) 不满足要求
        //解法二：用集合 set 时间O(N) 空间：O(N) 不满足要求
        //解法三：快慢指针，弗洛伊德的乌龟和兔子（循环检测）  （会认为你是有备而来的）时间复杂度0(1),空间复杂度O(N)
        //如果数组的每一个数的取值都是不重复的，那么可以选取特定的数值来使，不断通过索引值得到数值，再将新的数值作为索引值，循环下去可以得到一个链路。如果有重复数字，数组nums一定会存在一个环路，问题变为如何查找环路起点问题。
        int slow = 0,fast = 0;
        //快慢指针 两个指针先向前走，再判断是否两个指针相等
       do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while (slow!=fast);
        
        //找到环的入口结点
        int p1 = 0;
        int p2 = slow;
        while (p1!=p2){
            p1 = nums[p1];
            p2 = nums[p2];
        }
        return p1;
        
    }
};
